/**
\page AB_SettingUpACPFProject Setting up a CPF project 

This section shows how to create a CPF based project. Before doing so, it is recommended
that you get acquainted with the *CMakeProjectFramework* by building the example project as
described on the \ref AA_WorkingWithCPF page. You should also have basic knowledge on how
to work with Git.


\section StepByStep Step by step tutorial for creating a CPF project

This tutorial will walk you through the steps that are required to set-up a CPF project.
It will start with a very simple project that will then be extended to show more advanced features.
The goal of the tutorial is not only to create a new CPF project, but also to explain some of it's details
in the process. If you already know your way around a CPF project and you just want to create a new one, it is probably
quicker if you simply copy the example project and remove the stuff that you do not need and rename the rest.

This tutorial assumes that you work on Windows with Visual Studio 2017. It also assumes that you can run the python
scripts from the command line without prepending the extra \c python command. If you want to run this tutorial
on Linux, you have to use the base *Linux* configuration in the configuration step instead of the *Windows* configuration.
You may also want to choose different names for your generated configurations like *VS* &rarr; *Gcc* and *VS2017-shared* &rarr; *Gcc-shared*. 


\subsection CreateRepositories 1. Create the repository

First you need a Git repository that will hold your CI project. For simplicity sake we create the *remote* git repository on the same machine
that we use for working on the cloned repository. If you are familiar with setting up remote Git repositories you can
also create it on a different machine.

Navigate to a directory that is suited for holding the repositories. If you are on
Windows, make sure that it is a short directory name. The configuration name is used in multiple nested directories within
the build directory of the project, which can blow up the the 260 character path limit. Create
the directory \c MyCPFPRoject.git. This will contain the *remote* repository.
Now open a command line, and create the remote repository by executing the following commands:

\code{.unparsed}
>cd MyCPFPRoject.git
>git init --share --bare
\endcode

Clone the *remote* repository by executing the following commands:

\code{.unparsed}
>cd ..
>git clone MyCPFPRoject.git
\endcode

This will create the \c MyCPFProject directory. This is the root directory of your project
that we will use to add and edit source files. In the next section we will add some basic files to that
repository.

\subsection BasicCIprojectFiles 2. Basic CI project files

We now have the repository that will hold the files of our project.
First we add the basic files that are required for a CPF project.
You now have to create the files 

\code{.unparsed}
MyCPFProject
│   .gitignore
│
└───Sources
        CMakeLists.txt

\endcode

with the following content:


#### .gitignore ####

The file will make sure that directories and files that are generated by the CPF
are ignored by git.

\code{.unparsed}
# file MyCPFProject/.gitignore

Generated/**
Generated
Configuration/**
Configuration
Sources/*/cpfPackageVersion_*.cmake
1_Configure.py
2_Generate.py
3_Make.py
\endcode


#### CMakeLists.txt ####

This is the root \c CMakeLists.txt file of your CPF project. 

\code{.unparsed}
# file MyCPFProject/Sources/CMakeLists.txt

include("CPFCMake/Variables/cpfConstants.cmake")
cmake_minimum_required (VERSION ${CPF_MINIMUM_CMAKE_VERSION}) 

include("CPFCMake/cpfInit.cmake")

project(MyCPFProject)
cpfInit()

set( externalPackages
	cotire
	CPFCMake
	CPFBuildscripts
)

set( globalFiles
)

cpfAddPackages( "${externalPackages}" "${globalFiles}")

\endcode

- <tt>include("CPFCMake/Variables/cpfConstants.cmake")</tt>: Including this file provides us with the \c CPF_MINIMUM_CMAKE_VERSION that is
used in the next line. Alternatively you can set your own minimum version that must be equal or 
higher then the version that is required by the CPF.
- <tt>include("CPFCMake/cpfInit.cmake")</tt>: This file provides the \c cpfInit() and \c cpfAddPackages() functions.
- <tt>project(MyCPFProject)</tt>: This creates the so called *CI project*.
- <tt>cpfInit()</tt>: This function from \ref CPFCMakeGroup defines custom target properties, set some CMake policies 
and search for some of the tools that are required by the CPF pipeline.
- <tt>cpfAddPackages()</tt>: This function adds the packages and global files to the CI project. We add
the basic packages *cotire*, *CPFCMake* and *CPFBuildscripts* that are required for each CPF project.
As the packages are not yet in our repository, we add them as git submodules in the next step.

After creating the files you should now commit them to the repository and add a first version tag.
The tag is required by the CPF to determine the version number of the packages. If it is missing, the CPF
will later cause errors.

\code{.unparsed}
>git commit . -m"Add basic files"
>git tag -a 0.0.0 -m"The initial version"
\endcode


\subsection AddCPFPackages 3. Add the CPF packages

In the last section you added a \c CMakeLists.txt file that uses some functions from the *CPFCMake* package.
However, you do not have those functions yet available in your project. To change that we now add three packages 
as git submodules. Open a command line and navigate to the *Sources* directory. Then run:

\code{.unparsed}
>git submodule add https://github.com/Knitschi/CPFCMake.git
>git submodule add https://github.com/Knitschi/CPFBuildscripts.git
>git submodule add https://github.com/Knitschi/cotire.git
\endcode

The submodules \ref CPFCMakeGroup and \ref CPFBuildscriptsGroup are part of the CMakeProjectFramework. 
<i>Cotire</i> is an internal third party dependency of the CPF that implements the automatic use of pre-compiled headers.  


\subsection CPFRunGenerateForMyCPFProject 4. Run the generate step to create some more files

Now that we have acquired the CPF packages we can generate some more project files by running the generate step.
Run the following commands in the project root directory.

\code{.unparsed}
>Sources\CPFBuildscripts\0_Copyscripts.py
>1_Configure.py VS --inherits Windows
>2_Generate.py
\endcode

This will create three more files in the *Sources* directory. Your project tree should now look like this:

\code{.unparsed}
MyCPFProject
│   .gitignore
│   1_Configure.py
│   2_Generate.py
│   3_Make.py
│
├───Configuration
│       VS.config.cmake
│
├───Generated
│   └───VS
│           ...
│
└───Sources
    │   CMakeLists.txt
    │   cpfOwnedPackages.cmake
    │   DoxygenConfig.txt
    │   DoxygenLayout.xml
    │
    ├───cotire
    │       ...
    ├───CPFBuildscripts
    │       ...
    └───CPFCMake
            ...
    
\endcode

The files \c %cpfOwnedPackages.cmake, \c DoxygenConfig.txt and \c DoxygenLayout.xml need to be committed to the repository.
They are only generated when they do not exists and are intended to be edited by the developers. Run

\code{.unparsed}
>git commit . -m"Add more project files."
\endcode

to add them to the repository.

\subsection BasicPackageFiles 5. Add the MyApp application package

Our CI project is now ready. The only thing that is missing is some actual C++ code.
In order to add some *payload* code, we add a package directly to the *MyCPFProject*
repository. This is a package that creates an executable. Add the following 
file tree to the *Sources* directory.

\code{.unparsed}
Sources
│
└───MyApp
        CMakeLists.txt
        function.cpp
        function.h
        main.cpp

\endcode

The new files in the MyApp directory should have the following content.

#### CMakeLists.txt ####

\code{.cmake}
# file MyCPFProject/Sources/MyApp/CMakeLists.txt

include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ma )

set( briefDescription "A C++ command line application that prints a string." )
set( longDescription "The application is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PRODUCTION_FILES
	main.cpp
	function.cpp
	function.h
)

set( PACKAGE_LINKED_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					CONSOLE_APP
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
)
\endcode

- <tt>include(cpfAddPackage)</tt>: Provides the \c cpfInitPackageProject() and \c cpfAddPackage() functions.
- <tt>set( PACKAGE_NAMESPACE myapp )</tt>: The package namespace should be a short abbreviation of the package name.
It is used in multiple places.
    - As a part of the generated EXPORT MACRO that is used to publish symbol names in shared libraries.
    This is only relevant if the package is a library.
    - As the namespace of exported CMake targets which is also only relevant for library packages.
    - It is recommended but not necessary that you use that name also as C++ namespace for all source files
    in the package. The generated version header file at least uses this namespace.
- <tt>set( briefDescription ...</tt> and <tt>set( longDescription ...</tt>: The documentation pipeline will create 
an entry page for your packages documentation and fill it with the given strings. 
- <tt>cpfInitPackageProject()</tt>: This function retrieves the current version number of your package from
the repository. It also reads the directory name and writes it into \c PACKAGE_NAME. It also creates \c .cmake
and \c .h files that provide CMake and C++ code with the current package version.
- <tt>set( PACKAGE_PRODUCTION_FILES ...</tt>: A list with the currently available source files of the package. This is
a \c CMakeLists.txt file after all ;-).
- <tt>set( PACKAGE_LINKED_LIBRARIES ...</tt>: A list with targets on which the created package depends. For now we have
no dependencies so the list is empty.
- <tt>cpfAddPackage( ...</tt>: This function creates the package project and all the custom targets that belong to
a CPF package. The bigger part of \ref CPFCMakeGroup "CPFCMake's" functionality lies beneath this function.


#### function.cpp ####

This is a simple C++ file that implements a function. It represents your C++ code.

\code{.cpp}
// file MyCPFProject/Sources/MyApp/function.cpp

#include <MyApp/function.h>

#include <iostream>
#include <MyApp/cpfPackageVersion_MyApp.h>

namespace ma
{
    bool function()
    {
        std::cout << "MyApp (version " + getPackageVersion() + ") greets the world!" << std::endl;
        return true;
    }
}

\endcode

The file includes the generated file \c cpfPackageVersion_MyApp.h header which provides function \c ma::getPackageVersion() that returns the current version number.
Note that the include directories and the project directory structure in the CPF is laid-out that all includes can uniformly be
written with <tt>\#include <package/file.h></tt>. As recommended in the section for the \c CMakeLists.txt file we put our package functions into namespace *ma*.

#### function.h ####

\code{.cpp}
// file MyCPFProject/Sources/MyApp/function.h

#pragma once

namespace ma
{
    bool function();
}

\endcode

#### main.cpp ####

\code{.cpp}
// file MyCPFProject/Sources/MyApp/main.cpp

#include <MyApp/function.h>

int main(int, char**)
{
    return ma::function();
}

\endcode

\note The CPF expects the main function to be in the file \c main.cpp. In the case of a package that creates
an executable, the CPF internally creates a static library that contains all sources except the \c main.cpp file.
This is done to allow linking the complete functionality to a test executable that may also be created.

\subsubsection AddPackageToCIProject Add the owned package to the CI project

We now have to tell the CI-project that we added an *owned package*. We do this by adding *MyApp* to the
\c %cpfOwnedPackages.cmake file.

\code{.cmake}
# file MyCPFProject/Sources/cpfOwnedPackages.cmake

set( CPF_OWNED_PACKAGES
"\
MyApp;\
"
CACHE STRING "\
The packages that are owned by this CI-project. \
Packages must be sorted by their level in the dependency graph. \
Lower level packages must come first.\
" FORCE )

\endcode

Finally commit the new files to the repository by running:

\code{.unparsed}
>git commit . -m"Add the MyApp package."
\endcode

\subsubsection BuildTheSinglePackageProject Build the project

With all the files in place we can now build our package by executing the \ref BuildStep "build step".
If it succeeded you can also start the application

\code{.unparsed}
>3_Make.py --target pipeline
>Generated/VS/BuildStage/Debug/MyApp/MyApp-debug.exe
MyApp (version 0.0.0.3-73cc-dirty) greets the world!
\endcode

Your actual version number will be different and depends on the current
state of your repository. You can read more about the CPF versioning \ref Versioning "here".
The pipeline target will also generate the documentation web-page. To take a look at it open the file \c MyCPFProject/Generated/VS/html/doxygen/index.html.
In the *Modules* tab you will find a section for *MyApp*. If you follow the link you can see the automatically generated package main page
that contains the package descriptions from the \c CMakeLists.txt file. The links in the lower part will not work, because our
project does not generate the linked pages.



\subsection AddProjectConfig 6. Add a default configuration

For our first build we used one of the default configurations that come with the CPF, *Linux* or *Windows*.
You can find more detailed information about configurations in the CPF \ref CPFConfiguration "here".
In this section we add our own default configuration to the project. For demonstration purposes we change
the configuration to build shared libraries instead of static libraries. 
To create the new default configuration execute the following steps.

- First we create a new configuration file by running <tt>%1_Configure.py VS2017-shared --inherits Windows -D BUILD_SHARED_LIBS=ON</tt>.
This variable is used to tell CMake to build shared libraries instead of static ones. For now this has no effect because we have no
library packages yet. Instead of using the \c -D command line options, you can also
edit the configuration file with a text-editor, which may be more comfortable if multiple values are changed.

- Now create the directory \c Sources/CIBuildConfigurations and move the new configuration file at \c Configuration/VS2017-shared.config.cmake
into it.

- Commit the new configuration file to the repository.

Developers can now use the default configuration of the project without the need of manually setting any CMake variables.
In order to use your new default configuration delete the old configuration file in the *Configuration* directory
and create a new one by calling. <tt>1_Configure.py VS --inherits VS2017-shared</tt>. Then also re-run the
generate step by calling <tt>2_Generate.py VS</tt>.


\subsection CPFAddALibraryPackage 7. Add the library package MyLib

As your C++ project grows, it will at some point become reasonable to split it into multiple libraries.
In the CPF we create libraries by adding a library package. In this example we assume that our library
will be used by other projects. To Allow this, we create a separate repository for the library package.
We then add this repository as a git submodule to our *MyCPFProject* repository.
If you do not know if a library will be shared between projects, you can first add it directly to the 
CI repository to avoid the extra overhead of working with a git submodule. If need be, you can still put it 
in it's own repository later. 

Create a new repository with the name *MyLib* using the same steps that you executed when creating the
<i>MyCPFProject</i> repository. You should end up with two empty repositories, *MyLib.git* and *MyLib*. 
Both lie besides the *MyCPFProject.git* and *MyCPFProject* directories. We will first add some files to
the *MyLib* repository and then add it as git submodule to *MyCPFPRoject*.


\subsubsection CPFAddBasicLibPackageContent Add content to the MyLib repository

Add the following text-files to the *MyLib* repository and set the content as listed
in the sections below.

\code{.unparsed}
MyLib
    CMakeLists.txt
    function.cpp
    function.h
    .gitignore
\endcode


#### CMakeLists.txt ####

\code{.cmake}
# file MyLib/CMakeLists.txt

include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ml )

set( briefDescription "A C++ library that prints a string." )
set( longDescription "The library is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PUBLIC_HEADERS
    function.h
)

set( PACKAGE_PRODUCTION_FILES
	function.cpp
)

set( PACKAGE_LINKED_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
)
\endcode

This file has some differences compared to the \c MyApp\CMakeLists.txt file.

- We changed the name of the namespace and the description of the package.
- We changed the \c TYPE argument in the \c cofAddPackage() call in order to create a library package. 
- We added the \c PUBLIC_HEADER argument to the \c cofAddPackage() call. Libraries must provide
public headers for consumers. With the argument we can say which of our headers are supposed to be public.
Each library needs at least one public header or the project will fail to build.


#### function.h ####

\code{.cpp}
// file MyLib/function.h

#pragma once

#include <MyLib/ml_export.h>

namespace ml
{
	ML_EXPORT bool function();
}
\endcode

Note the use of the \c ML_EXPORT export macro. The macro is provided by the \c ml_export.h header
which is generated by CMake. Export macros are normally only needed when building shared libraries. 
However, it is good practice to let the clients of a library decide whether they want to use it as a shared 
or static a library. So better make sure that you always add the export macro to symbols that are intended 
to be used by clients. If you do not add the macro in a shared library, you will get linker errors.


#### function.cpp ####

\code{.cpp}
// file MyLib/function.cpp

#include <MyLib/function.h>

#include <iostream>
#include <MyLib/cpfPackageVersion_MyLib.h>

namespace ml
{
    bool function()
    {
        std::cout << "MyLib (version " + getPackageVersion() + ") greets the world!" << std::endl;
        return true;
    }
}
\endcode


#### .gitignore ####

The package repository needs its own \c .gitignore file. Add one with the following content:

\code{.unparsed}
# file MyLib/.gitignore
cpfPackageVersion_*
\endcode


Now add, commit and push all files in the *MyLib* repository. We also add an initial
version tag for the *MyLib* repository.

\code{.unparsed}
>git commit . -m"Add package files"
>git tag -a 0.0.0 -m"The initial version"
>git push --all
\endcode


\subsubsection CPFAddLibPackageToProject Add the MyLib package to the MyCPFProject repository.

Now add *MyLib* as a *loose owned package* to *MyCPFProject* as a git submodule
by running 

\code{.unparsed}
.../MyCPFProjec/Sources>git submodule add <your full path>/MyLib.git
\endcode

in the \c MyCPFProject/Sources directory. This will yield a *MyCPFPRoject/Sources/MyLib* directory
that contains the files that you created in the above section. To finish the process edit some files in *MyCPFPRoject*.

#### %cpfOwnedPackages.cmake ####

We add the *MyLib* package as owned package to CI project by adding it in the \c %cpfOwnedPackages.cmake file.
As the variable description states, it is essential that *MyLib* is added to the list before *MyApp*. 

\code{.cmake}
# file MyCPFProject/Sources/cpfOwnedPackages.cmake

set( CPF_OWNED_PACKAGES
"\
MyLib;\
MyApp;\
"
CACHE STRING "\
The packages that are owned by this CI-project. \
Packages must be sorted by their level in the dependency graph. \
Lower level packages must come first.\
" FORCE )
\endcode


#### MyApp/CMakeLists.txt ####

To make the functionality of *MyLib* available in *MyApp*,
we have to add it to the linked libraries of *MyApp*.

\code{.cmake}
# file MyCPFProject/Sources/MyApp/CMakeLists.txt

...
set(PACKAGE_LINKED_LIBRARIES
	MyLib
)
...
\endcode


#### MyApp/function.cpp ####

We extend our original \c ma::function() to also call the \c ml::function().

\code{.cpp}
// file MyCPFProject/Sources/MyApp/function.cpp

#include <MyApp/function.h>

#include <iostream>
#include <MyApp/cpfPackageVersion_MyApp.h>
#include <MyLib/function.h>

namespace ma
{
    bool function()
    {
        ml::function();

        std::cout << "MyApp (version " + getPackageVersion() + ") greets the world!";
        return true;
    }
}
\endcode

You now have to regenerate the make-files in order to finish adding the library package.

\code{.unparsed}
>2_Generate.py VS
>3_Make.py
>Generated/VS/BuildStage/Debug/MyApp/MyApp-debug.exe
MyLib (version 0.0.0) greets the world!
MyApp (version 0.0.0.6-3d31) greets the world!

\endcode

Again, your version numbers will be different. MyLib has a different version then then MyApp
because it lives in a different repository.



\subsection AddTests 8. Add a test-executable to MyLib

The CPF packages are designed to create an extra executable that runs automated tests for the packages
production code. This section will show you how to enable such a test executable for the *MyLib* package.
Add the new file *MyLib_tests_main.cpp* to a new *Tests* directory with the content

\code{.cpp}
// MyCPFProject/MyLib/Tests/MyLib_tests_main.cpp

#include <iostream>
#include <MyLib/function.h>

int main(int, char**)
{
    std::cout << "Run tests for MyLib" << std::endl;
    std::cout << std::endl;

    auto result = ml::function();
    if(result)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
\endcode

In a real project you would probably use the main function that is provided by your test-framework
instead of writing your own. Note that we placed the file into the arbitrary *Tests* subdirectory
which allows us to keep some order in our package. Change the packages \c CMakeLists.txt file content
to this:

\code{.cmake}
# file MyCPFProject/Sources/MyLib/CMakeLists.txt

include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ml )

set( briefDescription "A C++ library that prints a string." )
set( longDescription "The library is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PUBLIC_HEADERS
    function.h
)

set( PACKAGE_PRODUCTION_FILES
	function.cpp
)

set( PACKAGE_TEST_FILES
	Tests/MyLib_tests_main.cpp
)

set( PACKAGE_LINKED_LIBRARIES
)

set( PACKAGE_LINKED_TEST_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    TEST_FILES				${PACKAGE_TEST_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
    LINKED_TEST_LIBRARIES	${PACKAGE_LINKED_TEST_LIBRARIES}
)
\endcode

We added two new lists, \c PACKAGE_TEST_FILES and \c PACKAGE_LINKED_TEST_LIBRARIES and handed them
to the \c cpfAddPackage() function. The \c PACKAGE_TEST_FILES list should contain all source
files that are used to build the test executable. the \c PACKAGE_LINKED_TEST_LIBRARIES list
can be used to add linked libraries that are only used by the test executable. This could be a test-framework
library for example. In this example our test executable does not depend on any other library so we leave this empty.

You can now build and run your test executable by calling:
\code{.unparsed}
>3_Make.py --target runAllTests
\endcode

Somewhere in the output you should see the text output of the executable. Note that tests will not
be re-run if you execute the build command a second time. You have to edit at least one source
file of the package in order to outdate the test-run. If you then rebuild the *runAllTests* target
it will automatically create new binaries and run the tests with those.

For more information about the test targets of a CPF package see: \ref CPFCMakeTestTargets


\subsection AddFixtures 9. Add a fixture library to MyLib

When writing a lot of automated tests, it may become necessary to re-use test utility code from one package
in another. This could be fake or mock classes that you provide to replace the real objects in tests.
To make that possible, the CPF can create an extra *fixture* library per package that can contain reusable
test code. To demonstrate this, add two files \c Sources/MyLib/Tests/fixture.h and \c Sources/MyLib/Tests/fixture.cpp to the
MyLib package with the following content and add them to the \c CMakeLists.txt file as shown below.


#### Sources/MyLib/Tests/function_fixture.h ####

\code{.cpp}
// MyCPFProject/Sources/MyLib/Tests/function_fixture.h

#pragma once

#include <MyLib/ml_tests_export.h>

namespace ml
{
    ML_TESTS_EXPORT void prepareFunctionTest();
}
\endcode

- Note that the fixture library uses a different export macro then the production library.


#### Sources/MyLib/Tests/function_fixture.cpp ####

\code{.cpp}
// MyCPFProject/Sources/MyLib/Tests/function_fixture.cpp

#include <MyLib/Tests/function_fixture.h>

#include <iostream>

namespace ml
{
    void prepareFunctionTest()
    {
        std::cout << "Do reusable test preparations here" << std::endl;
    }
}

\endcode


#### Sources/MyLib/CMakeLists.txt ####

For the fixture library we have to distinguish between public header files and other source files.
Add the new files to new list variables and as arguments to the \c cpfAddPackage() call as shown below.

\code{.cmake}
# file MyCPFProject/Sources/MyLib/CMakeLists.txt
...
set( PACKAGE_PUBLIC_FIXTURE_HEADER
    Tests/function_fixture.h
)

set( PACKAGE_FIXTURE_FILES
    Tests/function_fixture.cpp
)
...

cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    TEST_FILES				${PACKAGE_TEST_FILES}
    PUBLIC_FIXTURE_HEADER	${PACKAGE_PUBLIC_FIXTURE_HEADER}
	FIXTURE_FILES			${PACKAGE_FIXTURE_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
    LINKED_TEST_LIBRARIES	${PACKAGE_LINKED_TEST_LIBRARIES}
)
\endcode


#### Sources/MyLib/Tests/MyLib_tests_main.cpp ####

Use the new function in the test code. The fixture library is called &lt;package&gt;_fixtures and is automatically linked to
the test executable. If you need it in the tests of another package you have to add it to that packages \c PACKAGE_LINKED_TEST_LIBRARIES variable.

\code{.cpp}
// file MyCPFProject/Sources/MyLib/Tests/MyLib_tests_main.cpp

#include <iostream>
#include <MyLib/function.h>
#include <MyLib/Tests/function_fixture.h>

int main(int, char**)
{
    std::cout << "Run tests for MyLib" << std::endl;
    std::cout << std::endl;

    ml::prepareFunctionTest();

    auto result = ml::function();
    if(result)
    {
        return 0;
    }
    else
    {
        return 1;
    }
    
}

\endcode

\subsubsection CPFCompileFixture Compile and run the fixture code

You can now compile and run your tests by calling

\code{.unparsed}
>3_Make --target runAllTests
...
Run tests for MyLib

Do reusable test preparations here
MyLib (version 0.0.0.2-6f37-dirty) greets the world!
...
\endcode


\subsection CPFAddDistributionPackages 10. Package the build results of MyLib

One part of a CI pipeline is to create some sort of package that can be downloaded by the users of the software.
For applications this is usually some sort of installer which can be arbitrarily complex. For libraries however,
this is usually just a ZIP archive that either holds the complete source code or the compiled artifacts and public headers.
In the CPF nomenclature we call these package files *distribution packages* in order to distinguish them from the
CPF code packages in the *Sources* directory.

To enable creating distribution packages you have to add one more argument to the \c cpfAddPackage() function.

#### Sources/MyLib/CMakeLists.txt ####

\code{.cmake}
# file MyCPFProject/Sources/MyLib/CMakeLists.txt
...
set( archiveDevPackageOptions
	DISTRIBUTION_PACKAGE_CONTENT_TYPE 	BINARIES_DEVELOPER
	DISTRIBUTION_PACKAGE_FORMATS 		7Z TGZ
)
...
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    TEST_FILES				${PACKAGE_TEST_FILES}
    PUBLIC_FIXTURE_HEADER	${PACKAGE_PUBLIC_FIXTURE_HEADER}
	FIXTURE_FILES			${PACKAGE_FIXTURE_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
    LINKED_TEST_LIBRARIES	${PACKAGE_LINKED_TEST_LIBRARIES}
    DISTRIBUTION_PACKAGES 	${archiveDevPackageOptions}
)
\endcode

- Note that the \c DISTRIBUTION_PACKAGES argument requires a list of nested key-word arguments, due to the complexity
of the option.
- The options in this example will cause the creation of a *developer binary* package in the formats \c .7z and \c .tar.gz.
*Developer binary* means, that the package will contain the compiled binaries and public headers.
- For more information about creating other kinds of distribution packages read: \ref CPFDistributionPackages

\subsubsection CPFBuildTheDistributionPackages Create the distribution package

In order to create the specified packages, run

\code{.unparsed}
>3_Make.py --target distributionPackages
\endcode

You should now have a directory \c MyCPFProject/Generated/VS/html/Downloads/MyLib/LastBuild with the two packages
<tt>MyLib.\<version\>.Windows.dev-bin.Debug.7z</tt> and <tt>MyLib.\<version\>.Windows.dev-bin.Debug.tar.gz</tt>.
The packages are added to the html directory so they can be directly downloaded from the projects web-page.


\section CPFProjectSetupSummary Summary

You now know the basics about setting up a CPF project. If you still have open questions, feel free to ask
them on the projects github page.

*/