/**
\page AB_SettingUpACPFProject Setting up a CPF project 

This section shows how to create a CPF based project. Before doing so, it is recommended
that you get acquainted with the CMakeProjectFramework by building the example project as
described on the \ref AA_WorkingWithCPF page. You should also have basic knowledge on how
to work with Git.


\section StepByStep Step by step tutorial for creating a CPF project

This tutorial will walk you through the single steps that are required to set up a CPF project.
It will start with a very simple project that will then be extended to get more advanced features.

\subsection CreateRepositories 1. Create the repository

First you need a Git repository that will hold your CI project. In this first approach we will
add all files to one repository. For simplicity sake we create the *remote* git repository on the same machine
that we use for working on the project. If you are familiar with setting up Git repositories you can
also create it on a remote machine.

Navigate to a directory that is suited for holding the repositories. If you are on
Windows, make sure that it is a short directory name, because of the nested directories within
the build directory of the project it is easy to hit the 260 character path limit. Create
the directory **MyCPFPRoject.git**. This will contain the *remote* repository.
Now open a command line, and create the remote repository by executing the following commands:

\code{.unparsed}
cd MyCPFPRoject.git
git init --share --bare
\endcode

Now navigate to the directory that holds the **MyCPFPRoject.git** directory and clone
your *remote* repository by executing the following commands:

\code{.unparsed}
git clone MyCPFPRoject.git
\endcode

This will create the **MyCPFProject** directory. This is the root directory of your project
on which we will actually work. In the next section we will add some basic files to that
repository.

\subsection BasicCIprojectFiles 2. Basic CI project files

We now have the repository that will hold the files of our project.
First we add the basic files that are required for a CPF project.
You now have to create the following file tree.

\code{.unparsed}
MyCPFProject
│   .gitignore
│
└───Sources
        CMakeLists.txt

\endcode

The files should have the following contents:


#### .gitignore ####

The file will make sure that the directories and files that are generated by the CPF
are ignored by git.

\code{.unparsed}
Generated/**
Generated
Configuration/**
Configuration
Sources/*/cpfPackageVersion_*.cmake
1_Configure.py
2_Generate.py
3_Make.py
\endcode


#### Sources/CMakeLists.txt ####

This is the root \c CMakeLists.txt file of your CPF project. 

\code{.unparsed}
include("CPFCMake/Variables/cpfConstants.cmake")
cmake_minimum_required (VERSION ${CPF_MINIMUM_CMAKE_VERSION}) 

include("CPFCMake/cpfInit.cmake")

project(MyCPFProject)
cpfInit()

set( externalPackages
	cotire
	CPFCMake
	CPFBuildscripts
)

set( globalFiles
)

cpfAddPackages( "${externalPackages}" "${globalFiles}")

\endcode

1. We first include a file from the \ref CPFCMakeGroup package that defines the minimum CMake version that
is required by the CPF. You can leave that away and set your own minimum version that must be equal or 
higher then the version that is required by the CPF.
4. Including the \c cpfInit.cmake module provides us with later used functions.
- Next we have the call to the CMake function \c project() which creates the so called CI project.
- Then we call \c cpfInit() which is provided by the \ref CPFCMakeGroup package. This function will
define custom target properties, set some CMake policies and search some of the tools that are
required by the CPF pipeline.
- The following lines are required to add external packages and global files to the CI project. We add
the basic packages *cotire*, *CPFCMake* and *CPFBuildscripts* that are required for each CPF project.
We will later add these packages as git submodules to the repository. 

\subsubsection CommitFirstFiles Add the basic files to the repository

After creating the files you can now add them to your repository by calling <tt>git add</tt> and <tt>git commit</tt>.
You should also add your first version tag by calling <tt>git tag -a 0.0.0 -m"The initial version"</tt>. If you do not
add this tag, the CPF will later fail to determine the current version tag and cause errors.


\subsection AddCPFPackages 3. Add the CPF packages

In the last section you added \c CMakeLists.txt file that uses some function of the CPF. However, you do not have those functions yet available
in your project. To change that we now add three packages as git submodules. Open a command line and navigate to the *Sources* directory.
Then run:

\code{.unparsed}
git submodule add https://github.com/Knitschi/CPFCMake.git
git submodule add https://github.com/Knitschi/CPFBuildscripts.git
git submodule add https://github.com/Knitschi/cotire.git
\endcode

The submodules \ref CPFCMakeGroup and \ref CPFBuildscriptsGroup are part of the CMakeProjectFramework.
*Cotire* is a third party dependency of the CPF that implements the automatic use of pre-compiled headers.  


\subsection Run the generate step to create some more files

No that we have acquired the CPF packages we can generate some more project files by running the generate step.
This is done by running the following commands in the project root directory.

#### Windows ####

\code{.unparsed}
python Sources\CPFBuildscripts\0_Copyscripts.py
python 1_Configure.py VisualStudio --inherits Windows
python 2_Generate.py
\endcode

#### Linux ####

\code{.unparsed}
python3 Sources\CPFBuildscripts\0_Copyscripts.py
python3 1_Configure.py Gcc --inherits Linux
python3 2_Generate.py
\endcode

This will create three more files in the *Sources* directory. Your project tree should now look like this:

\code{.unparsed}
MyCPFProject
│   .gitignore
│   1_Configure.py
│   2_Generate.py
│   3_Make.py
│
│
├───Configuration
│       VS.config.cmake
│
├───Generated
│   └───VS
│           ...
│
└───Sources
    │   CMakeLists.txt
    │   cpfOwnedPackages.cmake
    │   DoxygenConfig.txt
    │   DoxygenLayout.xml
    │
    ├───cotire
    │       ...
    ├───CPFBuildscripts
    │       ...
    └───CPFCMake
            ...
    
\endcode

The files \c cpfOwnedPackages.cmake, \c DoxygenConfig.txt and \c DoxygenLayout.xml need to be added to the repository.
They are only generated when they do not exists and are intended to be edited by the developers.


\subsection BasicPackageFiles 4. Basic package files

Our CI project is now ready. The only thing that is missing is some actual C++ code.
In order to add some *payload* code, we add a package directly to the *MyCPFProject*
repository. We will add a package that creates an executable. In order to do so you
have to add the following file tree to the *Sources* directory and the repository.

\code{.unparsed}
Sources
│
└───MyApp
        CMakeLists.txt
        function.cpp
        function.h
        main.cpp

\endcode

The new files in the MyApp directory should have the following content.

#### %Sources/MyApp/CMakeLists.txt ####

\code{.cmake}
include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ma )

set( briefDescription "A C++ command line application that prints a string." )
set( longDescription "The application is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PRODUCTION_FILES
	main.cpp
	function.cpp
	function.h
)

set( PACKAGE_LINKED_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					CONSOLE_APP
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
)
\endcode

- <tt>include(cpfAddPackage)</tt>: Provides the \c cpfInitPackageProject() and cpfAddPackage() functions.
- <tt>set( PACKAGE_NAMESPACE myapp )</tt>: The package namespace should be a short abbreviation of the package name.
It is used in multiple places.
    - As a part of the generated EXPORT MACRO that is used to publish symbol names in shared libraries.
    This is only relevant if the package is a library.
    - As the namespace of exported CMake targets.
    - It is recommended but not necessary that you use that name also as C++ namespace for all source files
    in the project.
- <tt>set( briefDescription ..</tt> and <tt>set( longDescription ..</tt>: The documentation pipeline will create 
the main documentation page for your package and fill it with the given strings. 
- <tt>cpfInitPackageProject()</tt>: This function retrieves the current version number of your package from
the repository. It also reads the directory name and writes it into \c PACKAGE_NAME. It will also create \c .cmake
and \c .h files with the current package version.
- <tt>set( PACKAGE_PRODUCTION_FILES ...</tt>: A list with the currently available source files of the package. This is
a \c CMakeLists.txt file after all ;-).
- <tt>set( PACKAGE_LINKED_LIBRARIES ...</tt>: A list with targets on which the created package depends. For now we have
no dependencies so the list is empty.
- <tt>cpfAddPackage( ...</tt>: This function creates the package project and all the custom targets that belong to
CPF package. The bigger part of \ref CPFCMakeGroup "CPFCMake's" functionality lies beneath this function.


#### %Sources/MyApp/function.cpp ####

This is a simple C++ file that implements a function.

\code{.cpp}
#include <MyApp/function.h>

#include <iostream>
#include <MyApp/cpfPackageVersion_MyApp.h>

namespace ma
{
    bool function()
    {
        std::cout << "MyApp (version " + getPackageVersion() + ") greets the world!" << std::endl;
        return true;
    }
}

\endcode

The file includes the generated file \c cpfPackageVersion_MyApp.h which provides a function that returns the current version number.
Note that the include directories and the project directory structure is laid out in a way that all includes can uniformly be
written with <tt>\#include <package/file.h></tt>. As recommended in the section for the \c CMakeLists.txt file we use <tt>namespace ma</tt>
here. The \c getPackageVersion() function is also defined in that namespace.

#### %Sources/MyApp/function.h ####

\code{.cpp}
#pragma once

namespace ma
{
    bool function();
}

\endcode

#### %Sources/MyApp/main.cpp ####

\code{.cpp}
#include <MyApp/function.h>

int main(int, char**)
{
    return ma::function();
}

\endcode

\note The CPF expects the main function to be in the file \c main.cpp. In the case of a package that creates
an executable, the CPF internally creates a static library that contains all sources except the \c main.cpp file.
The reason is, that you can link the complete functionality to test executable that may also be created.

\subsubsection AddPackageToCIProject Add the owned package to the CI project

We now have to tell the CI-project that we added an *owend package*. We do this by adding *MyApp* to the
\c cpfOwnedPackages.cmake file. Edit that file, that is looks like this:

\code{.cmake}
set( CPF_OWNED_PACKAGES
"\
MyApp;\
"
CACHE STRING "\
The packages that are owned by this CI-project. \
Packages must be sorted by their level in the dependency graph. \
Lower level packages must come first.\
" FORCE )

\endcode

\subsubsection BuildTheSinglePackageProject Build the project

With all the files in place we can now build our package by executing the \ref BuildStep "build step".
If it succeeded you can nor run the application by calling (on Windows)

\code{.unparsed}
...\MyCPFProject>Generated\VS\BuildStage\Debug\MyApp\MyApp-debug.exe
MyApp (version 0.0.0.3-73cc-dirty) greets the world!
\endcode

Your actual version number will be different and depends on the current
state of your repository. You can read more about the CPF versioning \ref Versioning "here".
Your project should now also have a web-page. To take a look at it open the file \c MyCPFProject/Generated/VS/html/doxygen/index.html.
In the *Modules* tab you will find a section for *MyApp*. If you follow the link you can see the auto-generated package main page
that contains the package descriptions from the \c CMakeLists.txt file. The links in the lower part will not work, because our
project does not generate the linked pages.


\subsection AddProjectConfig 5. Add a default configuration

For our first build we used one of the default configurations that come with the CPF, *Linux* or *Windows*.
Now we want to add our own default configuration to the project in order to build shared libraries instead
of static libraries. To create the new default configuration execute the following steps.

- First we create a new configuration file by running <tt>python 1_Configure.py VS2017-shared --inherits Windows -D BUILD_SHARED_LIBS=ON</tt>.
With this configuration we will build libraries as shared libraries. For now this will not have any effect because we have no
library packages yet. Instead of *VS2017-shared* you can choose any name you want, but on Windows it should be kept short to
reduce the risk of running into the 260 character limit for path names when building the project. Instead of using the \c -D command line options, you can also
edit the configuration file with a text-editor, which may be more comfortable if multiple values are changes.

- Now create the directory \c Sources/CIBuildConfigurations and move the new configuration file at \c Configuration/VS2017-shared.config.cmake
into it.

- Add and commit the new configuration file to the repository.

In order to use your new default configuration delete the old configuration file in the *Configuration* directory
and create a new one by calling. <tt>python 1_Configure.py VS --inherits VS2017-shared</tt>. Then also re-run the
generate step by calling <tt>python 2_Generate.py VS</tt>.


\subsection CPFAddALibraryPackage 6. Add a library package

As a C++ project grows, it will at some point become reasonable to split it up into multiple libraries.
In the CPF we create libraries by adding a library package. In this example we assume that our library
will be used by other projects. To Allow this, we have to add it as a git submodule to our *MyCPFPRoject*.

Create a new repository with the name *MyLib* with the same steps that you executed when creating the
*MyCPFProject* repository. You should end up with two empty repositories *MyLib.git* and *MyLib* that
lie besides the *MyCPFProject.git* and *MyCPFProject* directories. We will first add some files to
the MyLib repository and then add id as gitsubmodule to the *MyCPFPRoject* repository.


\subsubsection CPFAddBasicLibPackageContent Add content to the MyLib repository

Copy the \c CMakeLists.txt, \c function.h and \c function.cpp file from the *MyApp* package to
the new *MyLib* repository. Then edit the files to make sure they have the following content.

#### MyLib/CMakeLists.txt ####

\code{.cmake}
include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ml )

set( briefDescription "A C++ library that prints a string." )
set( longDescription "The library is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PUBLIC_HEADERS
    function.h
)

set( PACKAGE_PRODUCTION_FILES
	function.cpp
)

set( PACKAGE_LINKED_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
)
\endcode

- We changed the name of the namespace and the description of the package.
- We changed the \c TYPE argument in the \c cofAddPackage() call. 
- We added the \c PUBLIC_HEADER argument to the \c cofAddPackage() call. Libraries must provide
public headers for consumers. With the argument we can say which of our headers are supposed to public.
Each library needs at least one public header or it can not be consumed by clients.


#### MyLib/function.h ####

\code{.cpp}
#pragma once

#include <MyLib/ml_export.h>

namespace ml
{
	ML_EXPORT bool function();
}
\endcode

- We changed the namespace.
- We added the \c ML_EXPORT export macro. The macro is provided by the CMake generated \c ml_export.h header.
Export macros are normally only needed when building shared libraries. However, it is good practice to let the
clients of a library decide whether they want to use it as a shared or static library. So better make sure
that you always add the export macro to symbols that are intended to be used by clients of a library.


#### MyLib/function.cpp ####

\code{.cpp}
#include <MyLib/function.h>

#include <iostream>
#include <MyLib/cpfPackageVersion_MyLib.h>

namespace ml
{
    bool function()
    {
        std::cout << "MyLib (version " + getPackageVersion() + ") greets the world!" << std::endl;
        return true;
    }
}
\endcode

- We changed the includes, namespace and the output string. 


#### MyLib/.gitignore ####

The package repository needs its own \c .gitignore file. Add one with the following content:

\code{.unparsed}
cpfPackageVersion_*
\endcode


Now add, commit and push all files in the *MyLib* repository.

\code{.unparsed}
git commit . -m"Add package files"
git tag -a 0.0.0 -m"The initial version"
git push --all
\endcode


\subsubsection CPFAddLibPackageToProject Add the MyLib package to the MyCPFProject repository.

We now add *MyLib* as a *loose owned package* to *MyCPFProject*. First we add it as a submodule
by running 

\code{.unparsed}
git submodule add <your full path>/MyLib.git
\endcode

in the \c MyCPFProject/Sources directory. You should now have a *MyCPFPRoject/Sources/MyLib* directory
that contains the files the you created in the above section. Now we have to edit some files in the *MyCPFPRoject*.

#### Sources/cpfOwnedPackages.cmake ####

We add the *MyLib* package as owned package to CI project by adding it in the \c cpfOwnedPackages.cmake file.
As the variable description states, it is essential that *MyLib* is added to the list
before *MyApp*. 

\code{.cmake}
set( CPF_OWNED_PACKAGES
"\
MyLib;\
MyApp;\
"
CACHE STRING "\
The packages that are owned by this CI-project. \
Packages must be sorted by their level in the dependency graph. \
Lower level packages must come first.\
" FORCE )
\endcode


#### Sources/MyApp/CMakeLists.txt ####

Now we want to use the function provided by the *MyLib* package in the *MyApp* package.
To do so, we add it to the linked libraries of *MyApp*

\code{.cmake}
...
set(PACKAGE_LINKED_LIBRARIES
	MyLib
)
...
\endcode


#### Sources/MyApp/function.cpp ####

We now call the \c ml::function() in MyApp's \c ma::function().

\code{.cpp}
#include <MyApp/function.h>

#include <iostream>
#include <MyApp/cpfPackageVersion_MyApp.h>
#include <MyLib/function.h>

namespace ma
{
    bool function()
    {
        ml::function();

        std::cout << "MyApp (version " + getPackageVersion() + ") greets the world!";
        return true;
    }
}
\endcode


You now have to do a fresh generate step in order to finish adding library package.

\code{.unparsed}
>python 2_Generate.py VS
>python 3_Make.py
>Generated\VS\BuildStage\Debug\MyApp\MyApp-debug.exe
MyLib (version 0.0.0) greets the world!
MyApp (version 0.0.0.6-3d31) greets the world!

\endcode()

Again, your version numbers will be different.


\subsection AddTests 7. Add an executable for automated tests

The CPF packages are designed to create an extra executable that runs automated tests for the packages
production code. This section will show you how can enable the such a text executable for the *MyLib* package.
Add the new file *Sources/MyLib/Tests/MyLib_tests_main.cpp* to the new directory *Tests* with the content

\code{.cpp}
#include <iostream>
#include <MyLib/function.h>

int main(int, char**)
{
    std::cout << "Run tests for MyLib" << std::endl;
    std::cout << std::endl;

    auto result = ml::function();
    if(result)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
\endcode

In a real project you would probably use the main function that is provided by your test-framework.
Note that we placed the file into the arbitrary *Tests* subdirectory, which allows us to keep some
order in our package. We now also have to change the packages \c CMakeLists.txt to this content:

\code{.cmake}
include(cpfAddPackage)

# define namespace name for module
set( PACKAGE_NAMESPACE ml )

set( briefDescription "A C++ library that prints a string." )
set( longDescription "The library is so small that it needs no long description" )

cpfInitPackageProject(
	PACKAGE_NAME
	${PACKAGE_NAMESPACE}
)

set( PACKAGE_PUBLIC_HEADERS
    function.h
)

set( PACKAGE_PRODUCTION_FILES
	function.cpp
)

set( PACKAGE_TEST_FILES
	Tests/MyLib_tests_main.cpp
)

set( PACKAGE_LINKED_LIBRARIES
)

set( PACKAGE_LINKED_TEST_LIBRARIES
)

############################################## Add Package #################################
cpfAddPackage( 
	PACKAGE_NAME			${PACKAGE_NAME}
	PACKAGE_NAMESPACE		${PACKAGE_NAMESPACE}
	TYPE					LIB
	BRIEF_DESCRIPTION		${briefDescription}
	LONG_DESCRIPTION		${longDescription}
    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}
	PRODUCTION_FILES		${PACKAGE_PRODUCTION_FILES}
    LINKED_LIBRARIES		${PACKAGE_LINKED_LIBRARIES}
    LINKED_TEST_LIBRARIES	${PACKAGE_LINKED_TEST_LIBRARIES}
)
\endcode

We added two new list \c PACKAGE_TEST_FILES and \c PACKAGE_LINKED_TEST_LIBRARIES and handed them
to the \c cpfAddPackage() function. The \c PACKAGE_TEST_FILES list should contain all source
files that are used to build the test executable. the \c PACKAGE_LINKED_TEST_LIBRARIES list
can be used to add linked libraries that are only used by the test executable, like a test-framework
for example. For now our test executable does not depend on any other library so we leave this empty.

You can now build and run your test executable by calling:
\code{.unparsed}
python 3_Make.py --target runAllTests
\endcode

Somewhere in the output you should see the text output of the executable. Note that tests will not
be run again if you execute the build command a second time. You have to edit at least one source
file of the package in order to *outdate* the test-run. If you then rebuild the *runAllTests* target
it will automatically create new binaries and run the tests with those.

For more information about the test targets of a CPF package see: \ref CPFCMakeTestTargets


\subsection AddFixtures 8. Add a fixture library

When writing a lot of automated tests, we sometimes write test setup code that we want to
re-use in the tests of other packages, like fake- or mock- classes that can replace the real
objects in a test. The CPF can create an extra *fixture* library per package that can contain re-usable
test code. In order to do so you have to add two additional lists of source files  


\subsection CPFAddDistributionPackages 9. Package the build results

\subsection CPFAddExternalPackages X. Add an external dependency with the hunter package manager.


*/